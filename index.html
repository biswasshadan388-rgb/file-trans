<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>BigSend — Simple P2P Large File Transfer</title>
<style>
  :root{
    --bg:#0f1724; --card:#0b1220; --accent:#6ee7b7; --muted:#9aa4b2; --glass: rgba(255,255,255,0.03);
  }
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Arial;color:#e6eef6;background:linear-gradient(180deg,#041021 0%, #072033 100%);}
  .wrap{max-width:980px;margin:36px auto;padding:28px;border-radius:14px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 10px 30px rgba(3,7,18,0.6);}
  h1{margin:0;font-size:26px}
  p.lead{color:var(--muted);margin-top:6px}
  .grid{display:grid;grid-template-columns:1fr 360px;gap:20px;margin-top:20px}
  .card{background:var(--card);border-radius:12px;padding:16px;box-shadow:0 6px 18px rgba(2,6,12,0.6);border:1px solid rgba(255,255,255,0.03)}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  input[type=file]{display:block}
  button{background:linear-gradient(180deg,var(--accent),#43c99a);border:none;padding:10px 12px;border-radius:10px;color:#042127;font-weight:600;cursor:pointer}
  button.ghost{background:transparent;color:var(--accent);border:1px solid rgba(110,231,183,0.12)}
  button.small{padding:8px 10px;font-size:13px}
  textarea{width:100%;height:120px;background:var(--glass);border-radius:8px;border:1px solid rgba(255,255,255,0.03);color:#dff7ee;padding:10px;font-family:monospace;font-size:13px;resize:vertical}
  .row{display:flex;gap:10px;align-items:center}
  .muted{color:var(--muted);font-size:13px}
  .progress-wrap{display:flex;gap:10px;align-items:center}
  progress{width:100%;height:14px;border-radius:8px}
  .meta{font-size:13px;color:var(--muted);margin-top:8px}
  .log{height:140px;overflow:auto;background:#071221;padding:10px;border-radius:8px;color:#cfeee0;font-family:monospace;font-size:13px}
  .file-info{background:linear-gradient(90deg, rgba(255,255,255,0.012), rgba(255,255,255,0.01));padding:10px;border-radius:8px;font-size:14px;color:#dff7ee}
  .split{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .small-muted{font-size:12px;color:var(--muted)}
  .center{display:flex;align-items:center;justify-content:center}
  .footer{margin-top:18px;color:var(--muted);font-size:13px;text-align:center}
  .top-row{display:flex;justify-content:space-between;gap:10px;align-items:center}
  .copy-btn{background:transparent;border:1px dashed rgba(255,255,255,0.03);padding:6px;border-radius:8px;color:var(--muted);cursor:pointer}
  @media (max-width:920px){ .grid{grid-template-columns:1fr; } .card{padding:12px} textarea{height:100px} }
</style>
</head>
<body>
<div class="wrap">
  <div class="top-row">
    <div>
      <h1>BigSend</h1>
      <p class="lead">Direct peer-to-peer transfer of very large files (GBs) using WebRTC. No server storage required.</p>
    </div>
    <div class="muted small-muted">Works on desktop & mobile browsers (Chrome/Edge/Firefox). Use both devices on networks that allow P2P or use an internet signalling channel.</div>
  </div>

  <div class="grid">
    <div class="card">
      <h3>Sender / Receiver</h3>
      <div style="height:10px"></div>

      <div class="row" style="align-items:flex-start;gap:12px">
        <div style="flex:1">
          <label class="small-muted">Choose file to send</label>
          <div style="height:8px"></div>
          <input id="fileInput" type="file" />
          <div id="fileMeta" class="meta"></div>
          <div style="height:12px"></div>

          <div class="controls">
            <button id="btnCreateOffer">Create Offer (I am sender)</button>
            <button id="btnCreateAnswer" class="ghost small">Create Answer (I am receiver)</button>
            <button id="btnReset" class="ghost small">Reset</button>
          </div>

          <div style="height:12px"></div>

          <div class="split">
            <div>
              <label class="small-muted">Offer / Paste here</label>
              <textarea id="txtOffer" placeholder="Offer will appear here or paste the other side's offer"></textarea>
              <div style="display:flex;gap:8px;margin-top:8px">
                <button id="btnCopyOffer" class="small ghost">Copy Offer</button>
                <button id="btnPasteOffer" class="small ghost">Paste Offer</button>
              </div>
            </div>

            <div>
              <label class="small-muted">Answer / Paste here</label>
              <textarea id="txtAnswer" placeholder="Answer will appear here or paste the other side's answer"></textarea>
              <div style="display:flex;gap:8px;margin-top:8px">
                <button id="btnCopyAnswer" class="small ghost">Copy Answer</button>
                <button id="btnPasteAnswer" class="small ghost">Paste Answer</button>
              </div>
            </div>
          </div>

          <div style="height:12px"></div>
          <div class="file-info" id="transferState">Not connected</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h3>Status & Controls</h3>
      <div style="height:8px"></div>

      <div class="meta">Send / Receive progress</div>
      <div style="height:8px"></div>

      <div class="progress-wrap">
        <div style="width:12px"></div>
        <div style="flex:1">
          <label class="small-muted">Upload</label>
          <progress id="sendProgress" value="0" max="100"></progress>
          <div class="small-muted" id="sendStats">0 / 0</div>
        </div>
      </div>

      <div style="height:12px"></div>

      <div class="progress-wrap">
        <div style="width:12px"></div>
        <div style="flex:1">
          <label class="small-muted">Download</label>
          <progress id="recvProgress" value="0" max="100"></progress>
          <div class="small-muted" id="recvStats">0 / 0</div>
        </div>
      </div>

      <div style="height:12px"></div>

      <div class="meta">Connection log</div>
      <div style="height:8px"></div>
      <div class="log" id="log"></div>

      <div style="height:10px"></div>
      <div class="center">
        <button id="btnAutoCopy" class="ghost small">Auto-copy generated Offer/Answer</button>
      </div>

      <div class="footer">Tip: Use the same page on both devices. One creates Offer → paste to other → other creates Answer → paste back.</div>
    </div>
  </div>
</div>

<script>
/*
  BigSend (single-file) — P2P large file transfer using WebRTC DataChannels.
  - Uses chunked binary sends with backpressure checks (bufferedAmount).
  - Control messages are JSON strings; file chunks are ArrayBuffer.
  - Flow:
     Sender: createOffer() -> send offer to receiver -> receiver sets remote desc, creates answer -> sender sets remote desc.
     Sender sends metadata {type:'meta', name, size} then binary chunks, then {type:'done'}.
     Receiver builds array of ArrayBuffers -> creates Blob -> offers download link.
*/

const logEl = id('log');
const txtOffer = id('txtOffer'), txtAnswer = id('txtAnswer');
const btnCreateOffer = id('btnCreateOffer'), btnCreateAnswer = id('btnCreateAnswer');
const btnCopyOffer = id('btnCopyOffer'), btnCopyAnswer = id('btnCopyAnswer');
const btnPasteOffer = id('btnPasteOffer'), btnPasteAnswer = id('btnPasteAnswer');
const fileInput = id('fileInput'), fileMeta = id('fileMeta');
const sendProgress = id('sendProgress'), recvProgress = id('recvProgress');
const sendStats = id('sendStats'), recvStats = id('recvStats');
const transferState = id('transferState');
const btnReset = id('btnReset'), btnAutoCopy = id('btnAutoCopy');

let pc = null;
let dataChannel = null;
let incomingBuffers = [];
let incomingSize = 0;
let incomingMeta = null;
let fileToSend = null;
let autoCopy = true;

// Chunk size: 64KB is a good balance (increase if you want fewer sends)
const CHUNK_SIZE = 64 * 1024; // 64 KiB
// Backpressure threshold: pause sending if bufferedAmount > this
const MAX_BUFFERED_AMOUNT = 16 * 1024 * 1024; // 16 MB
const DRAIN_WAIT_MS = 50;

function id(x){ return document.getElementById(x); }
function log(msg){ logEl.textContent += `[${new Date().toLocaleTimeString()}] ${msg}\n`; logEl.scrollTop = logEl.scrollHeight; }

function resetState(){
  if(pc){
    try{ pc.close(); }catch(e){}
  }
  pc = new RTCPeerConnection();
  pc.oniceconnectionstatechange = ()=> log("ICE: " + pc.iceConnectionState);
  pc.ondatachannel = e => {
    log("DataChannel created (remote).");
    dataChannel = e.channel;
    setupChannel();
  };
  incomingBuffers = []; incomingSize = 0; incomingMeta = null;
  fileToSend = null;
  fileInput.value = "";
  fileMeta.textContent = "";
  sendProgress.value = 0; recvProgress.value = 0;
  sendStats.textContent = "0 / 0"; recvStats.textContent = "0 / 0";
  transferState.textContent = "Not connected";
}
resetState();

fileInput.addEventListener('change', ()=>{
  const f = fileInput.files[0];
  if(!f) { fileMeta.textContent = ""; fileToSend = null; return; }
  fileToSend = f;
  fileMeta.textContent = `Selected: ${f.name} — ${(f.size/1024/1024).toFixed(2)} MB`;
});

btnReset.onclick = ()=>{
  resetState();
  txtOffer.value = ""; txtAnswer.value = "";
  log("Reset complete.");
};

// Create offer (sender)
btnCreateOffer.onclick = async ()=>{
  resetState();
  if(!fileToSend){ alert("Pick a file first (sender)."); return; }

  dataChannel = pc.createDataChannel("file");
  setupChannel();

  log("Creating offer...");
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  await waitForIceGatheringComplete(pc);

  const payload = JSON.stringify(pc.localDescription);
  txtOffer.value = payload;
  if(autoCopy) copyText(payload);

  log("Offer created. Share this Offer with receiver.");
  transferState.textContent = "Offer created — waiting for answer";
};

// Create answer (receiver)
btnCreateAnswer.onclick = async ()=>{
  resetState();
  const offerText = txtOffer.value.trim();
  if(!offerText){ alert("Paste the Offer from the sender into the Offer box first."); return; }

  try{
    const offerDesc = JSON.parse(offerText);
    await pc.setRemoteDescription(offerDesc);
  }catch(e){ alert("Invalid offer JSON."); return; }

  log("Creating answer...");
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  await waitForIceGatheringComplete(pc);

  const payload = JSON.stringify(pc.localDescription);
  txtAnswer.value = payload;
  if(autoCopy) copyText(payload);
  log("Answer created. Paste it back to sender.");
  transferState.textContent = "Answer created — paste back to sender";
};

// Paste helpers
btnPasteOffer.onclick = async ()=> {
  try {
    const text = await navigator.clipboard.readText();
    txtOffer.value = text;
    log("Pasted Offer from clipboard.");
  } catch(e){ log("Clipboard read failed."); }
};
btnPasteAnswer.onclick = async ()=> {
  try {
    const text = await navigator.clipboard.readText();
    txtAnswer.value = text;
    log("Pasted Answer from clipboard.");
  } catch(e){ log("Clipboard read failed."); }
};

btnCopyOffer.onclick = ()=> { copyText(txtOffer.value); };
btnCopyAnswer.onclick = ()=> { copyText(txtAnswer.value); };
btnAutoCopy.onclick = ()=> { autoCopy = !autoCopy; btnAutoCopy.textContent = autoCopy ? "Auto-copy: ON" : "Auto-copy: OFF"; }

// When user pastes answer into answer textarea, apply it
txtAnswer.addEventListener('input', async ()=>{
  const v = txtAnswer.value.trim();
  if(!v) return;
  try{
    const desc = JSON.parse(v);
    await pc.setRemoteDescription(desc);
    log("Remote description set (answer).");
    transferState.textContent = "Connected (remote description set)";
  }catch(e){
    // ignore invalid JSON while typing
  }
});

// Wait for ICE gathering (collect candidates)
function waitForIceGatheringComplete(pc){
  return new Promise(resolve=>{
    if(pc.iceGatheringState === 'complete') resolve();
    function check(){
      if(pc.iceGatheringState === 'complete'){
        pc.removeEventListener('icegatheringstatechange', check);
        resolve();
      }
    }
    pc.addEventListener('icegatheringstatechange', check);
    // Safety: also resolve after 5s
    setTimeout(resolve, 5000);
  });
}

function setupChannel(){
  dataChannel.binaryType = 'arraybuffer';
  dataChannel.onopen = ()=> {
    log("DataChannel open. You may start transfer.");
    transferState.textContent = "Connected: data channel open";
    // Sender: send metadata then chunks
    if(fileToSend && dataChannel.readyState === 'open'){
      setTimeout(()=> sendFile(fileToSend), 50);
    }
  };
  dataChannel.onclose = ()=> { log("DataChannel closed."); transferState.textContent = "Closed"; };
  dataChannel.onerror = (e)=> { log("DataChannel error: " + e.message); };
  dataChannel.onmessage = async (evt)=>{
    // Check if text control or binary
    if(typeof evt.data === 'string'){
      try{
        const msg = JSON.parse(evt.data);
        if(msg.type === 'meta'){
          incomingMeta = msg;
          incomingBuffers = [];
          incomingSize = 0;
          recvProgress.value = 0;
          recvStats.textContent = `0 / ${formatBytes(incomingMeta.size)}`;
          log(`Receiving file: ${incomingMeta.name} (${formatBytes(incomingMeta.size)})`);
        } else if(msg.type === 'done'){
          log('All parts received. Constructing file...');
          assembleFile();
        } else if(msg.type === 'cancel'){
          log('Sender cancelled the transfer.');
        }
      }catch(e){
        log('Text message parse error: ' + e.message);
      }
    } else if(evt.data instanceof ArrayBuffer){
      incomingBuffers.push(evt.data);
      incomingSize += evt.data.byteLength;
      // update progress
      if(incomingMeta){
        const p = Math.min(100, Math.round((incomingSize / incomingMeta.size) * 100));
        recvProgress.value = p;
        recvStats.textContent = `${formatBytes(incomingSize)} / ${formatBytes(incomingMeta.size)}`;
      } else {
        recvStats.textContent = `${formatBytes(incomingSize)} / ?`;
      }
      log(`Received chunk: ${formatBytes(evt.data.byteLength)} (total ${formatBytes(incomingSize)})`);
    }
  };
}

async function sendFile(file){
  if(!dataChannel || dataChannel.readyState !== 'open') { log('Channel not open yet'); return; }
  log('Starting send: ' + file.name + ' (' + formatBytes(file.size) + ')');

  // Send metadata
  dataChannel.send(JSON.stringify({ type:'meta', name: file.name, size: file.size }));
  // Send chunks
  const fileSize = file.size;
  let offset = 0;
  const reader = new FileReader();

  // helper to read slice as arraybuffer
  function readSlice(o){
    return new Promise((resolve, reject) => {
      const slice = file.slice(o, Math.min(fileSize, o + CHUNK_SIZE));
      reader.onload = e => resolve(e.target.result);
      reader.onerror = e => reject(e);
      reader.readAsArrayBuffer(slice);
    });
  }

  let lastLoggedPercent = -1;
  try{
    while(offset < fileSize){
      // backpressure handling
      if(dataChannel.bufferedAmount > MAX_BUFFERED_AMOUNT){
        // wait until buffered amount drains
        await waitForDrain();
      }
      const chunk = await readSlice(offset);
      dataChannel.send(chunk);
      offset += chunk.byteLength;
      const percent = Math.round((offset / fileSize) * 100);
      sendProgress.value = percent;
      sendStats.textContent = `${formatBytes(offset)} / ${formatBytes(fileSize)}`;
      if(percent !== lastLoggedPercent && percent % 5 === 0){
        log('Sent ' + percent + '%');
        lastLoggedPercent = percent;
      }
    }
    // tell receiver we're done
    dataChannel.send(JSON.stringify({ type:'done' }));
    sendProgress.value = 100;
    sendStats.textContent = `${formatBytes(fileSize)} / ${formatBytes(fileSize)}`;
    log('Send complete.');
  }catch(e){
    log('Send error: ' + e.message);
    try{ dataChannel.send(JSON.stringify({ type:'cancel' })); }catch(_){}
  }
}

function waitForDrain(){
  return new Promise(resolve => {
    const check = ()=>{
      if(!dataChannel){ resolve(); return; }
      if(dataChannel.bufferedAmount <= MAX_BUFFERED_AMOUNT/2) { resolve(); }
      else setTimeout(check, DRAIN_WAIT_MS);
    };
    setTimeout(check, DRAIN_WAIT_MS);
  });
}

function assembleFile(){
  if(!incomingMeta) { log('No incoming metadata — cannot assemble.'); return; }
  const blob = new Blob(incomingBuffers);
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = incomingMeta.name || 'download.bin';
  a.style.display = 'none';
  document.body.appendChild(a);
  a.click();
  setTimeout(()=> {
    URL.revokeObjectURL(url);
    a.remove();
  }, 10000);
  log('Download started for ' + (incomingMeta.name || 'file'));
  transferState.textContent = 'Received: ' + incomingMeta.name;
}

// utility: format bytes
function formatBytes(bytes){
  if(bytes === 0) return '0 B';
  const k = 1024, sizes = ['B','KB','MB','GB','TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k,i)).toFixed(2)) + ' ' + sizes[i];
}

// copy helper
function copyText(t){
  if(!t) return;
  navigator.clipboard.writeText(t).then(()=> {
    log('Copied to clipboard.');
  }).catch(()=> { log('Copy failed — maybe not allowed by browser.'); });
}

log('Ready. Pick a file, click "Create Offer" on sender, share offer with receiver, create answer and paste back.');

// ICE candidate logging
if(pc) pc.onicecandidate = e => {
  // ignore — we gather local SDP in waitForIceGatheringComplete
};

// small helpful keyboard shortcuts
document.addEventListener('keydown', (e)=>{
  if(e.ctrlKey && e.key === 'r'){ e.preventDefault(); resetState(); log('Reset (Ctrl+R)'); }
});
</script>
</body>
</html>
